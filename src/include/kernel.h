// kernel.h

#ifndef __KERNEL__
#define __KERNEL__

#include <string>

const std::string KernelString = "// kernel.cl\n\n// bvh.cl\n\n#ifndef __BVH__\n#define __BVH__\n\n// bound3d.cl\n\n#ifndef __BOUND3D__\n#define __BOUND3D__\n\n// Ray.cl\n\n#ifndef __RAY__\n#define __RAY__\n\ntypedef struct Ray {\n    float3 origin;\n    float3 dir;\n    float tMin;\n    float tMax;\n} Ray;\n\nRay RayInit(float3 origin, float3 dir, float tMin, float tMax) {\n    Ray ray;\n    ray.origin = origin;\n    ray.dir = dir;\n    ray.tMin = tMin;\n    ray.tMax = tMax;\n    return ray;\n}\n\nRay RayInitEmpty() {\n    Ray ray;\n    ray.origin = (float3){0.0f, 0.0f, 0.0f};\n    ray.dir = (float3){0.0f, 0.0f, 0.0f};\n    ray.tMin = 0.0f;\n    ray.tMax = 0.0f;\n    return ray;\n}\n\nfloat3 RayAt(Ray ray, float t) {\n    return ray.origin + ray.dir * t;\n}\n\n#endif // __RAY__\n// bool3.cl\n\n#ifndef __BOOL3__\n#define __BOOL3__\n\n#define bool3 char3\n\n#endif // __BOOL3__\n\ntypedef struct Bound3D {\n    float3 pMin;\n    float3 pMax;\n} Bound3D;\n\ntypedef struct Bound3DIntersectInfo {\n    bool isHit;\n    float3 tMin;\n    float3 tMax;\n} Bound3DIntersectInfo;\n\nBound3D Bound3DInit(float3 pMin, float3 pMax) {\n    Bound3D bound;\n    bound.pMin = pMin;\n    bound.pMax = pMax;\n    return bound;\n}\n\nBound3D Bound3DInitEmpty() {\n    Bound3D bound;\n    bound.pMin = (float3){INFINITY, INFINITY, INFINITY};\n    bound.pMax = (float3){-INFINITY, -INFINITY, -INFINITY};\n    return bound;\n}\n\nbool Bound3DIsValid(Bound3D bound) {\n    return bound.pMax.x >= bound.pMin.x && bound.pMax.y >= bound.pMin.y && bound.pMax.z >= bound.pMin.z;\n}\n\nfloat3 Bound3DDiagnal(Bound3D bound) {\n    return bound.pMax - bound.pMin;\n}\n\nint Bound3DMaxExtentDimension(Bound3D bound) {\n    float3 diagnal = Bound3DDiagnal(bound);\n    return diagnal.x > diagnal.y ? (diagnal.x > diagnal.z ? 0 : 2) : (diagnal.y > diagnal.z ? 1 : 2);\n}\n\nfloat3 Bound3DSurfaceArea(Bound3D bound) {\n    float3 diagnal = Bound3DDiagnal(bound);\n    return 2.0f * (diagnal.x * diagnal.y + diagnal.y * diagnal.z + diagnal.x * diagnal.z);\n}\n\nfloat3 Bound3DOffset(Bound3D bound, float3 p) {\n    float3 pOffset = p - bound.pMin;\n    float3 diagnal = bound.pMax - bound.pMin;\n    return (float3){pOffset.x / diagnal.x, pOffset.y / diagnal.y, pOffset.z / diagnal.z};\n}\n\nBound3D Bound3DUnionBound3D(Bound3D boundA, Bound3D boundB) {\n    Bound3D bound;\n    bound.pMin = min(boundA.pMin, boundB.pMin);\n    bound.pMax = max(boundA.pMax, boundB.pMax);\n    return bound;\n}\n\nBound3D Bound3DUnionPoint(Bound3D bound, float3 p) {\n    bound.pMin = min(bound.pMin, p);\n    bound.pMax = max(bound.pMax, p);\n    return bound;\n}\n\nBound3DIntersectInfo Bound3DIntersectInfoInit(float tMin, float tMax) {\n    Bound3DIntersectInfo boundIsect;\n    boundIsect.isHit = tMin <= tMax;\n    boundIsect.tMin = tMin;\n    boundIsect.tMax = tMax;\n    return boundIsect;\n}\n\nBound3DIntersectInfo Bound3DIntersect(Bound3D bound, Ray ray, bool3 rayDirIsNeg, float3 invRayDir) {\n    float txMin = ((rayDirIsNeg.x ? bound.pMax : bound.pMin).x - ray.origin.x) * invRayDir.x;\n    float txMax = ((rayDirIsNeg.x ? bound.pMin : bound.pMax).x - ray.origin.x) * invRayDir.x;\n    \n    float tyMin = ((rayDirIsNeg.y ? bound.pMax : bound.pMin).y - ray.origin.y) * invRayDir.y;\n    float tyMax = ((rayDirIsNeg.y ? bound.pMin : bound.pMax).y - ray.origin.y) * invRayDir.y;\n    \n    float tzMin = ((rayDirIsNeg.z ? bound.pMax : bound.pMin).z - ray.origin.z) * invRayDir.z;\n    float tzMax = ((rayDirIsNeg.z ? bound.pMin : bound.pMax).z - ray.origin.z) * invRayDir.z;\n    \n    float tMin = max(max(max(txMin, tyMin), tzMin), ray.tMin);\n    float tMax = min(min(min(txMax, tyMax), tzMax), ray.tMax);\n    \n    return Bound3DIntersectInfoInit(tMin, tMax);\n}\n\nbool Bound3DIsIntersect(Bound3D bound, Ray ray, bool3 rayDirIsNeg, float3 invRayDir) {\n    float txMin = ((rayDirIsNeg.x ? bound.pMax : bound.pMin).x - ray.origin.x) * invRayDir.x;\n    float txMax = ((rayDirIsNeg.x ? bound.pMin : bound.pMax).x - ray.origin.x) * invRayDir.x;\n    \n    float tyMin = ((rayDirIsNeg.y ? bound.pMax : bound.pMin).y - ray.origin.y) * invRayDir.y;\n    float tyMax = ((rayDirIsNeg.y ? bound.pMin : bound.pMax).y - ray.origin.y) * invRayDir.y;\n    \n    float tzMin = ((rayDirIsNeg.z ? bound.pMax : bound.pMin).z - ray.origin.z) * invRayDir.z;\n    float tzMax = ((rayDirIsNeg.z ? bound.pMin : bound.pMax).z - ray.origin.z) * invRayDir.z;\n    \n    float tMin = max(max(max(txMin, tyMin), tzMin), ray.tMin);\n    float tMax = min(min(min(txMax, tyMax), tzMax), ray.tMax);\n    \n    return tMin <= tMax;\n}\n\n#endif // __BOUND3D__\n// intersectinfo.cl\n\n#ifndef __INTERSECTINFO__\n#define __INTERSECTINFO__\n\ntypedef struct IntersectInfo {\n    bool isHit;\n    float tHit;\n} IntersectInfo;\n\nIntersectInfo IntersectInfoInit(float tHit) {\n    IntersectInfo isect;\n    isect.isHit = true;\n    isect.tHit = tHit;\n    return isect;\n}\n\nIntersectInfo IntersectInfoInitNone() {\n    IntersectInfo isect;\n    isect.isHit = false;\n    isect.tHit = 0.0f;\n    return isect;\n}\n\n#endif // __INTERSECTINFO__\n// Triangle.hlsl\n\n#ifndef __TRIANGLE__\n#define __TRIANGLE__\n\n\ntypedef struct Triangle {\n    float3 v[3];\n} Triangle;\n\nIntersectInfo TriangleIntersect(Triangle tri, Ray ray) {\n    float3 e0 = tri.v[0] - tri.v[2];\n    float3 e1 = tri.v[1] - tri.v[0];\n    float3 e2 = tri.v[2] - tri.v[1];\n    \n    float3 normal = normalize(cross(e1, e2));\n    \n    float t = dot(tri.v[0] - ray.origin, normal) / dot(ray.dir, normal);\n    \n    IntersectInfo isect;\n\n    if (t <= ray.tMin || t >= ray.tMax) {\n        isect = IntersectInfoInitNone();\n    }\n    else {\n        float3 p = RayAt(ray, t);\n    \n        float b0 = dot(cross(e0, p - tri.v[2]), normal);\n        float b1 = dot(cross(e1, p - tri.v[0]), normal);\n        float b2 = dot(cross(e2, p - tri.v[1]), normal);\n    \n        if ((b0 >= 0 && b1 >= 0 && b2 >= 0) || (b0 <= 0 && b1 <= 0 && b2 <= 0)) {\n            isect = IntersectInfoInit(t);\n        }\n        else {\n            isect = IntersectInfoInitNone();\n        }\n    }\n\n    return isect;\n}\n\nbool TriangleIsIntersect(Triangle tri, Ray ray) {\n    float3 e0 = tri.v[0] - tri.v[2];\n    float3 e1 = tri.v[1] - tri.v[0];\n    float3 e2 = tri.v[2] - tri.v[1];\n    \n    float3 normal = normalize(cross(e1, e2));\n    \n    float t = dot(tri.v[0] - ray.origin, normal) / dot(ray.dir, normal);\n    \n    bool isHit;\n\n    if (t <= ray.tMin || t >= ray.tMax) {\n        isHit = false;\n    }\n    else {\n        float3 p = RayAt(ray, t);\n    \n        float b0 = dot(cross(e0, p - tri.v[2]), normal);\n        float b1 = dot(cross(e1, p - tri.v[0]), normal);\n        float b2 = dot(cross(e2, p - tri.v[1]), normal);\n    \n        if ((b0 >= 0 && b1 >= 0 && b2 >= 0) || (b0 <= 0 && b1 <= 0 && b2 <= 0)) {\n            isHit = true;\n        }\n        else {\n            isHit = false;\n        }\n    }\n\n    return isHit;\n}\n\n#endif // __TRIANGLE__\n\ntypedef struct BVHNode {\n    // Second Child Index for Interior Node\n    // Triangle Index fot Leaf Node\n    int index;\n\n    // -1 for Leaf Node\n    int splitAxis;\n\n    Bound3D bound;\n} BVHNode;\n\n__constant int maxBVHDepth = 32;\n\nBVHNode InitInterior(Bound3D bound, int secondChildIndex, int splitAxis) {\n    BVHNode node;\n    node.bound = bound;\n    node.index = secondChildIndex;\n    node.splitAxis = splitAxis;\n    return node;\n}\n\nBVHNode InitLeaf(Bound3D bound, int triangleIndex) {\n    BVHNode node;\n    node.bound = bound;\n    node.index = triangleIndex;\n    node.splitAxis = -1;\n    return node;\n}\n\nIntersectInfo BVHIntersect(__global const BVHNode *bvhNodes,\n                           const int bvhNodeCount,\n                           __global const Triangle *triangles,\n                           Ray ray) {\n    IntersectInfo isect = IntersectInfoInitNone();\n    int stack[maxBVHDepth];\n    int stackOffset = 0;\n    float3 invRayDir = (float3){1.0f / ray.dir.x, 1.0f / ray.dir.y, 1.0f / ray.dir.z};\n    bool3 rayDirIsNeg = (bool3){ray.dir.x < 0.0f ? 1 : 0,\n                                ray.dir.y < 0.0f ? 1 : 0, \n                                ray.dir.z < 0.0f ? 1 : 0};\n\n    for (int i = 0; i < bvhNodeCount;) {\n        BVHNode node = bvhNodes[i];\n        if (Bound3DIsIntersect(node.bound, ray, rayDirIsNeg, invRayDir)) {\n            if (node.splitAxis != -1) {\n                if (rayDirIsNeg[node.splitAxis]) {\n                    stack[stackOffset++] = i + 1;\n                    i = node.index;\n                }\n                else {\n                    stack[stackOffset++] = node.index;\n                    i++;\n                }\n            }\n            else {\n                Triangle tri = triangles[node.index];\n                IntersectInfo tempIsect = TriangleIntersect(tri, ray);\n                if (tempIsect.isHit) {\n                    ray.tMax = tempIsect.tHit;\n                    isect = tempIsect;\n                }\n                \n                if (stackOffset == 0) {\n                    break;\n                }\n                i = stack[--stackOffset];\n            }\n        }\n        else {\n            if (stackOffset == 0) {\n                break;\n            }\n            i = stack[--stackOffset];\n        }\n    }\n    \n    return isect;\n}\n\nbool BVHIsIntersect(const BVHNode *bvhNodes, const int bvhNodeCount, const Triangle *triangles, Ray ray) {\n    bool isHit = false;\n    int stack[maxBVHDepth];\n    int stackOffset = 0;\n    float3 invRayDir = (float3) 1.0f / ray.dir;\n    bool3 rayDirIsNeg = (bool3){ray.dir.x < 0.0f, ray.dir.y < 0.0f, ray.dir.z < 0.0f};\n    \n    for (int i = 0; i < bvhNodeCount;) {\n        BVHNode node = bvhNodes[i];\n        if (Bound3DIsIntersect(node.bound, ray, rayDirIsNeg, invRayDir)) {\n            if (node.splitAxis != -1) {\n                if (rayDirIsNeg[node.splitAxis]) {\n                    stack[stackOffset++] = i + 1;\n                    i = node.index;\n                }\n                else {\n                    stack[stackOffset++] = node.index;\n                    i++;\n                }\n            }\n            else {\n                Triangle tri = triangles[node.index];\n                if (TriangleIsIntersect(tri, ray)) {\n                    isHit = true;\n                    break;\n                }\n                \n                if (stackOffset == 0) {\n                    break;\n                }\n                i = stack[--stackOffset];\n            }\n        }\n        else {\n            if (stackOffset == 0) {\n                break;\n            }\n            i = stack[--stackOffset];\n        }\n    }\n    \n    return isHit;\n}\n\n#endif // __BVH__\n// constant.cl\n\n#ifndef __CONSTANT__\n#define __CONSTANT__\n\n__constant float PI = 3.1415926535898f;\n__constant float TWOPI = 6.2831853071796f;\n\n#endif // __CONSTANT__\n// random.cl\n\n#ifndef __RANDOM__\n#define __RANDOM__\n\n__constant uint LCG_A = (uint) 16807;\n__constant uint LCG_C = (uint) 0;\n__constant uint LCG_M = (uint) 2147483647;\n\ntypedef struct Random {\n    uint seed;\n} Random;\n\nRandom RandomInit(int threadID) {\n    Random random;\n\n    uint n = (uint) threadID;\n    n = n * 1664525u + 1013904223u;\n    n += n * n;\n    n ^= n >> 16u;\n    n += n * n;\n\n    random.seed = n;\n    return random;\n}\n\nuint RandomUint(Random *random) {\n    random->seed = (random->seed * LCG_A + LCG_C) % LCG_M;\n    return random->seed;\n}\n\nfloat Random01(Random *random) {\n    return (float) (RandomUint(random) - (uint) 1) / (float) (LCG_M - (uint) 1);\n}\n\nfloat Random11(Random *random) {\n    return Random01(random) * 2.0f - 1.0f;\n}\n\n#endif // __RANDOM__\n\n__kernel void RenderKernel(__global const BVHNode *bvhNodes,\n                           const int bvhNodeCount,\n                           __global const Triangle *triangles,\n                           const int triangleCount,\n                           __global float *outputBuffer,\n                           const int width,\n                           const int height) {\n    int index = get_global_id(0);\n    if (index < width * height) {\n        Random random = RandomInit(index);\n        int i = index / width;\n        int j = index % width;\n        float dh = TWOPI / width;\n        float dv = PI / height;\n        float h = j * dh;\n        float v = PI / 2 - i * dv;\n\n        Ray ray = RayInit((float3){0.0f, 0.0f, 0.0f},\n                          normalize((float3){cos(v) * cos(h), cos(v) * sin(h), sin(v)}),\n                          0.0f,\n                          INFINITY);\n\n        IntersectInfo isect;\n        isect = BVHIntersect(bvhNodes, bvhNodeCount, triangles, ray);\n        if (!isect.isHit) {\n            for (int n = 0; n < 10; n++) {\n                float h_rand = h + dh * Random11(&random) * 0.05f;\n                float v_rand = v + dv * Random11(&random) * 0.05f;\n\n                ray = RayInit((float3){0.0f, 0.0f, 0.0f},\n                              normalize((float3){cos(v_rand) * cos(h_rand), cos(v_rand) * sin(h_rand), sin(v_rand)}),\n                              0.0f,\n                              INFINITY);\n\n                isect = BVHIntersect(bvhNodes, bvhNodeCount, triangles, ray);\n                if (isect.isHit) {\n                    break;\n                }\n            }\n        }\n\n        outputBuffer[index] = isect.isHit ? isect.tHit : 0.0f;\n    }\n}\n\n__kernel void FilterKernel(__global const float *inputBuffer,\n                           __global float *outputBuffer,\n                           const int width,\n                           const int height) {\n    int index = get_global_id(0);\n    if (index < width * height) {\n        int x = index % width;\n        int y = index / width;\n        float currentPixel = inputBuffer[index];\n        if (currentPixel > 0.0f) {\n            outputBuffer[index] = currentPixel;\n        }\n\n        float sum = 0.0f;\n        int count = 0;\n        for (int i = x - 1; i <= x + 1; i++) {\n            for (int j = y - 1; j <= y + 1; j++) {\n                if (i >= 0 && i < width && j >= 0 && j < height) {\n                    float pixel = inputBuffer[j * width + i];\n                    if (i != x && j != y && pixel > 0.0f) {\n                        sum += pixel;\n                        count++;\n                    }\n                }\n            }\n        }\n\n        if (count != 0) {\n            currentPixel = sum / count;\n        }\n\n        outputBuffer[index] = currentPixel;\n    }\n}\n\n__kernel void MinMaxKernel(__global const float *buffer,\n                           const int bufferLength,\n                           __global uint *minValue,\n                           __global uint *maxValue) {\n    int index = get_global_id(0);\n    if (index < bufferLength) {\n        uint value = as_uint(max(0.0f, buffer[index]));\n        atomic_min(minValue, value);\n        atomic_max(maxValue, value);\n    }\n}\n\n";

#endif // __KERNEL__